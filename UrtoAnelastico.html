<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Urto Perfettamente Anelastico â€” Lezione 4L</title>
<link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=JetBrains+Mono:wght@400;500&family=Source+Sans+3:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0f1117;
    --surface: #181b24;
    --surface2: #1f2330;
    --accent: #4fc3f7;
    --accent2: #ff7043;
    --accent3: #66bb6a;
    --text: #e0e0e0;
    --text-dim: #8a8fa8;
    --text-bright: #ffffff;
    --border: #2a2e3d;
    --formula-bg: #141720;
    --shadow: 0 8px 32px rgba(0,0,0,0.4);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  html { scroll-behavior: smooth; }

  body {
    font-family: 'Source Sans 3', sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.7;
    font-size: 17px;
  }

  /* â”€â”€ Header â”€â”€ */
  .hero {
    min-height: 50vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 4rem 2rem;
    background: linear-gradient(170deg, #0f1117 0%, #161a28 40%, #1a1e30 100%);
    position: relative;
    overflow: hidden;
  }

  .hero::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle at 60% 70%, rgba(79,195,247,0.06) 0%, transparent 50%),
                radial-gradient(circle at 30% 30%, rgba(255,112,67,0.04) 0%, transparent 50%);
    pointer-events: none;
  }

  .hero h1 {
    font-family: 'Crimson Pro', serif;
    font-size: clamp(2.2rem, 5vw, 3.8rem);
    font-weight: 700;
    color: var(--text-bright);
    margin-bottom: 0.5rem;
    letter-spacing: -0.5px;
    position: relative;
  }

  .hero h1 span {
    color: var(--accent);
  }

  .hero .subtitle {
    font-size: 1.15rem;
    color: var(--text-dim);
    font-weight: 300;
    margin-bottom: 2rem;
  }

  .hero .class-badge {
    display: inline-block;
    background: rgba(79,195,247,0.12);
    border: 1px solid rgba(79,195,247,0.25);
    color: var(--accent);
    padding: 0.35rem 1.2rem;
    border-radius: 100px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    letter-spacing: 1px;
  }

  /* â”€â”€ Navigation â”€â”€ */
  nav {
    position: sticky;
    top: 0;
    z-index: 100;
    background: rgba(15,17,23,0.92);
    backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--border);
    padding: 0.8rem 2rem;
    display: flex;
    gap: 0.5rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  nav a {
    color: var(--text-dim);
    text-decoration: none;
    font-size: 0.85rem;
    font-weight: 500;
    padding: 0.4rem 1rem;
    border-radius: 6px;
    transition: all 0.25s;
  }

  nav a:hover {
    color: var(--accent);
    background: rgba(79,195,247,0.08);
  }

  /* â”€â”€ Main content â”€â”€ */
  main {
    max-width: 820px;
    margin: 0 auto;
    padding: 2rem 1.5rem 6rem;
  }

  section {
    margin-bottom: 4rem;
    animation: fadeInUp 0.6s ease both;
  }

  @keyframes fadeInUp {
    from { opacity: 0; transform: translateY(24px); }
    to { opacity: 1; transform: translateY(0); }
  }

  h2 {
    font-family: 'Crimson Pro', serif;
    font-size: 1.9rem;
    font-weight: 700;
    color: var(--text-bright);
    margin-bottom: 1.2rem;
    padding-bottom: 0.6rem;
    border-bottom: 2px solid var(--border);
    display: flex;
    align-items: center;
    gap: 0.6rem;
  }

  h2 .num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    color: var(--accent);
    background: rgba(79,195,247,0.1);
    padding: 0.25rem 0.6rem;
    border-radius: 4px;
    font-weight: 500;
  }

  h3 {
    font-family: 'Crimson Pro', serif;
    font-size: 1.35rem;
    color: var(--text-bright);
    margin: 1.8rem 0 0.8rem;
    font-weight: 600;
  }

  p { margin-bottom: 1rem; }

  /* â”€â”€ Formula boxes â”€â”€ */
  .formula-box {
    background: var(--formula-bg);
    border: 1px solid var(--border);
    border-left: 3px solid var(--accent);
    border-radius: 8px;
    padding: 1.5rem 1.8rem;
    margin: 1.5rem 0;
    font-family: 'JetBrains Mono', monospace;
    font-size: 1.05rem;
    text-align: center;
    line-height: 2;
    box-shadow: var(--shadow);
    position: relative;
    overflow: hidden;
  }

  .formula-box::after {
    content: '';
    position: absolute;
    top: 0; right: 0;
    width: 80px; height: 80px;
    background: radial-gradient(circle, rgba(79,195,247,0.06), transparent 70%);
    pointer-events: none;
  }

  .formula-box .label {
    display: block;
    font-family: 'Source Sans 3', sans-serif;
    font-size: 0.78rem;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 1.5px;
    margin-bottom: 0.6rem;
    font-weight: 600;
  }

  .formula-box .formula {
    color: var(--text-bright);
    font-size: 1.15rem;
  }

  .formula sub { font-size: 0.75em; }
  .formula sup { font-size: 0.75em; }

  /* â”€â”€ Key concept cards â”€â”€ */
  .concept-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 1.5rem;
    margin: 1.5rem 0;
  }

  .concept-card.warning {
    border-left: 3px solid var(--accent2);
  }

  .concept-card.success {
    border-left: 3px solid var(--accent3);
  }

  .concept-card .card-title {
    font-weight: 600;
    color: var(--text-bright);
    margin-bottom: 0.5rem;
    font-size: 1rem;
  }

  .concept-card.warning .card-title { color: var(--accent2); }
  .concept-card.success .card-title { color: var(--accent3); }

  /* â”€â”€ Animation canvases â”€â”€ */
  .sim-container {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 1rem;
    margin: 2rem 0;
    box-shadow: var(--shadow);
  }

  .sim-container .sim-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1.5px;
    margin-bottom: 0.8rem;
    text-align: center;
  }

  canvas {
    display: block;
    width: 100%;
    border-radius: 8px;
    background: #0d0f15;
  }

  .sim-controls {
    display: flex;
    justify-content: center;
    gap: 0.8rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }

  .sim-controls button {
    font-family: 'Source Sans 3', sans-serif;
    font-size: 0.9rem;
    font-weight: 500;
    padding: 0.5rem 1.4rem;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--surface2);
    color: var(--text);
    cursor: pointer;
    transition: all 0.2s;
  }

  .sim-controls button:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(79,195,247,0.08);
  }

  .sim-controls button.primary {
    background: rgba(79,195,247,0.15);
    border-color: var(--accent);
    color: var(--accent);
  }

  .sim-info {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.5rem;
    margin-top: 1rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.82rem;
    color: var(--text-dim);
  }

  .sim-info div {
    background: var(--formula-bg);
    padding: 0.5rem 0.8rem;
    border-radius: 4px;
  }

  .sim-info .val {
    color: var(--text-bright);
    font-weight: 500;
  }

  /* â”€â”€ Steps / procedure â”€â”€ */
  .step {
    display: flex;
    gap: 1rem;
    margin: 1.2rem 0;
    align-items: flex-start;
  }

  .step-num {
    flex-shrink: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(79,195,247,0.12);
    color: var(--accent);
    border-radius: 50%;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85rem;
    font-weight: 500;
    margin-top: 2px;
  }

  .step-content { flex: 1; }

  /* â”€â”€ Table â”€â”€ */
  .comparison-table {
    width: 100%;
    border-collapse: collapse;
    margin: 1.5rem 0;
    font-size: 0.95rem;
  }

  .comparison-table th {
    background: var(--surface2);
    color: var(--accent);
    font-weight: 600;
    text-align: left;
    padding: 0.8rem 1rem;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    border-bottom: 2px solid var(--border);
  }

  .comparison-table td {
    padding: 0.7rem 1rem;
    border-bottom: 1px solid var(--border);
  }

  .comparison-table tr:last-child td {
    border-bottom: none;
  }

  /* â”€â”€ Footer â”€â”€ */
  footer {
    text-align: center;
    padding: 3rem 2rem;
    color: var(--text-dim);
    font-size: 0.85rem;
    border-top: 1px solid var(--border);
  }

  /* â”€â”€ Responsive â”€â”€ */
  @media (max-width: 600px) {
    main { padding: 1.5rem 1rem 4rem; }
    .sim-info { grid-template-columns: 1fr; }
    nav { padding: 0.6rem 1rem; }
    nav a { font-size: 0.78rem; padding: 0.3rem 0.6rem; }
  }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HERO â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="hero">
  <div class="class-badge">CLASSE 4L â€” FISICA</div>
  <h1>L'urto perfettamente <span>anelastico</span></h1>
  <p class="subtitle">Quando due corpi si uniscono: quantitÃ  di moto, energia e pendoli balistici</p>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• NAV â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<nav>
  <a href="#idea">L'idea chiave</a>
  <a href="#formula">La formula</a>
  <a href="#sim1">Animazione 1</a>
  <a href="#energia">Energia</a>
  <a href="#pendolo">Pendolo balistico</a>
  <a href="#sim2">Animazione 2</a>
  <a href="#metodo">Metodo</a>
  <a href="#riepilogo">Riepilogo</a>
</nav>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<main>

<!-- â”€â”€ 1. L'idea chiave â”€â”€ -->
<section id="idea">
  <h2><span class="num">01</span> L'idea chiave</h2>
  <p>
    Immaginate due oggetti che si scontrano e, dopo l'urto, <strong>restano attaccati</strong> e si muovono insieme. Questo Ã¨ un <em>urto perfettamente anelastico</em>.
  </p>
  <p>
    Esempi concreti: un proiettile che si conficca in un sacco, due pattinatori che si afferrano, una freccia che si pianta in un bersaglio. In tutti questi casi, dopo l'urto c'Ã¨ <strong>un unico corpo</strong> che si muove con una velocitÃ  da determinare.
  </p>

  <div class="concept-card success">
    <div class="card-title">âœ“ Cosa si conserva</div>
    <p>La <strong>quantitÃ  di moto</strong> totale del sistema si conserva sempre, in qualsiasi tipo di urto, purchÃ© non ci siano forze esterne significative.</p>
  </div>

  <div class="concept-card warning">
    <div class="card-title">âœ— Cosa NON si conserva</div>
    <p>L'<strong>energia cinetica</strong> non si conserva nell'urto anelastico. Parte dell'energia viene dissipata in calore, deformazione e suono.</p>
  </div>
</section>

<!-- â”€â”€ 2. La formula fondamentale â”€â”€ -->
<section id="formula">
  <h2><span class="num">02</span> La formula fondamentale</h2>

  <p>
    Applichiamo la conservazione della quantitÃ  di moto. Prima dell'urto, ogni corpo ha la propria massa e velocitÃ . Dopo l'urto, i due corpi formano un unico sistema di massa (mâ‚ + mâ‚‚) che si muove con velocitÃ  v<sub>f</sub>.
  </p>

  <div class="formula-box">
    <span class="label">Conservazione della quantitÃ  di moto</span>
    <div class="formula">
      mâ‚ Â· vâ‚ + mâ‚‚ Â· vâ‚‚ = (mâ‚ + mâ‚‚) Â· v<sub>f</sub>
    </div>
  </div>

  <p>Da cui ricaviamo la velocitÃ  finale:</p>

  <div class="formula-box">
    <span class="label">VelocitÃ  dopo l'urto</span>
    <div class="formula">
      v<sub>f</sub> = (mâ‚ Â· vâ‚ + mâ‚‚ Â· vâ‚‚) / (mâ‚ + mâ‚‚)
    </div>
  </div>

  <div class="concept-card">
    <div class="card-title">ğŸ“ Nota sui segni</div>
    <p>Scegliete un verso positivo. Se un corpo si muove nel verso opposto, la sua velocitÃ  sarÃ  <strong>negativa</strong>. Questo Ã¨ fondamentale quando i due corpi vengono da direzioni opposte (come nell'esercizio dei pattinatori).</p>
  </div>

  <h3>Caso speciale: bersaglio fermo</h3>
  <p>
    Se il secondo corpo Ã¨ inizialmente fermo (vâ‚‚ = 0), come negli esercizi con proiettile e bersaglio, la formula si semplifica:
  </p>

  <div class="formula-box">
    <span class="label">Bersaglio fermo (vâ‚‚ = 0)</span>
    <div class="formula">
      v<sub>f</sub> = mâ‚ Â· vâ‚ / (mâ‚ + mâ‚‚)
    </div>
  </div>

  <p>
    Notate che se mâ‚‚ â‰« mâ‚ (il bersaglio Ã¨ molto piÃ¹ pesante del proiettile), la velocitÃ  finale sarÃ  molto piccola. Tutta la Â«furiaÂ» del proiettile viene assorbita dalla grande massa.
  </p>
</section>

<!-- â”€â”€ 3. Animazione 1: urto lineare â”€â”€ -->
<section id="sim1">
  <h2><span class="num">03</span> Simulazione: urto su binario</h2>
  <p>
    Osservate cosa succede quando un corpo piccolo e veloce colpisce un corpo grande e fermo. Dopo l'urto restano attaccati e si muovono insieme (molto piÃ¹ lentamente!).
  </p>

  <div class="sim-container">
    <div class="sim-title">Urto perfettamente anelastico â€” binario senza attrito</div>
    <canvas id="canvas1" width="760" height="220"></canvas>
    <div class="sim-controls">
      <button class="primary" onclick="startSim1()">â–¶ Avvia</button>
      <button onclick="resetSim1()">â†º Reset</button>
    </div>
    <div class="sim-info" id="info1">
      <div>mâ‚ = <span class="val">0.50 kg</span></div>
      <div>vâ‚ = <span class="val">6.0 m/s</span></div>
      <div>mâ‚‚ = <span class="val">2.50 kg</span></div>
      <div>vâ‚‚ = <span class="val">0.0 m/s</span></div>
      <div>p<sub>prima</sub> = <span class="val" id="p_prima1">3.00 kgÂ·m/s</span></div>
      <div>v<sub>f</sub> = <span class="val" id="vf1">â€” m/s</span></div>
      <div>Ek<sub>prima</sub> = <span class="val" id="ek_prima1">9.00 J</span></div>
      <div>Ek<sub>dopo</sub> = <span class="val" id="ek_dopo1">â€” J</span></div>
    </div>
  </div>
</section>

<!-- â”€â”€ 4. Energia nell'urto anelastico â”€â”€ -->
<section id="energia">
  <h2><span class="num">04</span> L'energia cinetica: cosa succede?</h2>

  <p>
    Anche se la quantitÃ  di moto si conserva, l'energia cinetica <strong>no</strong>. Calcoliamo quanto se ne perde.
  </p>

  <div class="formula-box">
    <span class="label">Energia cinetica</span>
    <div class="formula">
      E<sub>k</sub> = Â½ Â· m Â· vÂ²
    </div>
  </div>

  <p>
    Per trovare la percentuale di energia dissipata:
  </p>

  <div class="formula-box">
    <span class="label">Percentuale di energia persa</span>
    <div class="formula">
      % persa = (E<sub>k,prima</sub> âˆ’ E<sub>k,dopo</sub>) / E<sub>k,prima</sub> Ã— 100
    </div>
  </div>

  <h3>Dove va l'energia persa?</h3>
  <p>
    L'energia cinetica Â«scomparsaÂ» non Ã¨ davvero scomparsa. Si Ã¨ trasformata in:
  </p>
  <div class="concept-card">
    <div class="card-title">Forme di energia dissipata</div>
    <p>
      <strong>Calore</strong> â€” i materiali si scaldano per la deformazione<br>
      <strong>Deformazione permanente</strong> â€” il proiettile si schiaccia, il legno si rompe<br>
      <strong>Suono</strong> â€” l'onda d'urto che sentiamo come Â«bottoÂ»
    </p>
  </div>

  <h3>Un risultato sorprendente</h3>
  <p>
    Nell'esercizio 1 (proiettile nel sacco), si perde circa il <strong>99,98%</strong> dell'energia cinetica! Quasi tutta l'energia del proiettile finisce in calore e deformazione. Solo una minuscola frazione muove il sacco pesante.
  </p>
</section>

<!-- â”€â”€ 5. Il pendolo balistico â”€â”€ -->
<section id="pendolo">
  <h2><span class="num">05</span> Il pendolo balistico</h2>

  <p>
    Dopo l'urto, se il sistema Ã¨ appeso come un pendolo, l'energia cinetica acquisita si trasforma in energia potenziale gravitazionale man mano che il blocco sale.
  </p>

  <div class="formula-box">
    <span class="label">Conservazione dell'energia meccanica (dopo l'urto)</span>
    <div class="formula">
      Â½(mâ‚ + mâ‚‚) Â· v<sub>f</sub>Â² = (mâ‚ + mâ‚‚) Â· g Â· h
    </div>
  </div>

  <p>Le masse si semplificano e otteniamo:</p>

  <div class="formula-box">
    <span class="label">Relazione velocitÃ  â€” altezza</span>
    <div class="formula">
      v<sub>f</sub>Â² = 2 g h &nbsp;&nbsp;âŸ¹&nbsp;&nbsp; h = v<sub>f</sub>Â² / (2g)
    </div>
  </div>

  <p>E l'altezza Ã¨ legata all'angolo della fune:</p>

  <div class="formula-box">
    <span class="label">Geometria del pendolo</span>
    <div class="formula">
      h = L Â· (1 âˆ’ cos Î¸)
    </div>
  </div>

  <div class="concept-card success">
    <div class="card-title">ğŸ”‘ Strategia in due fasi</div>
    <p>
      <strong>Fase 1 (urto):</strong> si conserva la quantitÃ  di moto â†’ trovo v<sub>f</sub><br>
      <strong>Fase 2 (pendolo):</strong> si conserva l'energia meccanica â†’ trovo h e Î¸
    </p>
    <p style="margin-top:0.5rem; color: var(--accent2);">
      Attenzione: non si puÃ² usare la conservazione dell'energia durante l'urto! Solo dopo.
    </p>
  </div>

  <h3>Il problema inverso</h3>
  <p>
    Il pendolo balistico funziona anche Â«al contrarioÂ» (esercizio 4): si misura l'altezza h, si ricava v<sub>f</sub> dalla formula dell'energia, e poi si risale alla velocitÃ  del proiettile con la formula della quantitÃ  di moto. Ãˆ un metodo ingegnoso perchÃ© misurare un'altezza con un righello Ã¨ molto piÃ¹ facile che misurare la velocitÃ  istantanea di un proiettile!
  </p>
</section>

<!-- â”€â”€ 6. Animazione 2: pendolo balistico â”€â”€ -->
<section id="sim2">
  <h2><span class="num">06</span> Simulazione: pendolo balistico</h2>
  <p>
    Guardate il proiettile colpire il blocco appeso: dopo l'urto, il blocco sale oscillando come un pendolo. L'altezza raggiunta dipende dalla velocitÃ  subito dopo l'urto.
  </p>

  <div class="sim-container">
    <div class="sim-title">Pendolo balistico â€” proiettile nel blocco</div>
    <canvas id="canvas2" width="760" height="360"></canvas>
    <div class="sim-controls">
      <button class="primary" onclick="startSim2()">â–¶ Avvia</button>
      <button onclick="resetSim2()">â†º Reset</button>
    </div>
    <div class="sim-info" id="info2">
      <div>m<sub>proiettile</sub> = <span class="val">0.010 kg</span></div>
      <div>v<sub>proiettile</sub> = <span class="val">850 m/s</span></div>
      <div>m<sub>blocco</sub> = <span class="val">4.0 kg</span></div>
      <div>v<sub>f</sub> = <span class="val" id="vf2">â€” m/s</span></div>
      <div>h<sub>max</sub> = <span class="val" id="hmax2">â€” m</span></div>
      <div>Î¸<sub>max</sub> = <span class="val" id="thetamax2">â€” Â°</span></div>
    </div>
  </div>
</section>

<!-- â”€â”€ 7. Attrito dopo l'urto â”€â”€ -->
<section id="attrito">
  <h2><span class="num">07</span> E se c'Ã¨ attrito dopo l'urto?</h2>
  <p>
    Nell'esercizio 3 (freccia e carrello), dopo l'urto il sistema si muove su una superficie con attrito. L'energia cinetica viene dissipata dall'attrito lungo la distanza di frenata.
  </p>

  <div class="formula-box">
    <span class="label">Teorema dell'energia cinetica</span>
    <div class="formula">
      F<sub>attrito</sub> Â· d = Â½ Â· m Â· v<sub>f</sub>Â²
    </div>
  </div>

  <p>
    Da questa relazione, conoscendo la distanza d e la velocitÃ  v<sub>f</sub>, potete ricavare la forza di attrito media. Oppure viceversa: conoscendo l'attrito, potete trovare la distanza di arresto.
  </p>
</section>

<!-- â”€â”€ 8. Metodo di risoluzione â”€â”€ -->
<section id="metodo">
  <h2><span class="num">08</span> Come risolvere gli esercizi</h2>

  <div class="step">
    <div class="step-num">1</div>
    <div class="step-content">
      <strong>Disegna la situazione</strong> â€” Fai uno schizzo con i corpi prima e dopo l'urto. Indica masse, velocitÃ  e il verso positivo scelto.
    </div>
  </div>

  <div class="step">
    <div class="step-num">2</div>
    <div class="step-content">
      <strong>Scrivi la conservazione di p</strong> â€” Imposta l'equazione mâ‚vâ‚ + mâ‚‚vâ‚‚ = (mâ‚ + mâ‚‚)Â·v<sub>f</sub> e ricava la velocitÃ  finale. Attento alle unitÃ : converti i grammi in kg!
    </div>
  </div>

  <div class="step">
    <div class="step-num">3</div>
    <div class="step-content">
      <strong>Calcola le energie</strong> â€” Se richiesto, calcola E<sub>k</sub> prima e dopo l'urto e la percentuale dissipata.
    </div>
  </div>

  <div class="step">
    <div class="step-num">4</div>
    <div class="step-content">
      <strong>Fase successiva</strong> â€” Se dopo l'urto c'Ã¨ un pendolo, usa la conservazione dell'energia meccanica. Se c'Ã¨ attrito, usa il teorema dell'energia cinetica.
    </div>
  </div>

  <div class="step">
    <div class="step-num">5</div>
    <div class="step-content">
      <strong>Controlla il risultato</strong> â€” La velocitÃ  finale dev'essere piÃ¹ piccola della velocitÃ  iniziale del corpo piÃ¹ veloce. La quantitÃ  di moto totale prima e dopo deve coincidere.
    </div>
  </div>
</section>

<!-- â”€â”€ 9. Riepilogo formule â”€â”€ -->
<section id="riepilogo">
  <h2><span class="num">09</span> Riepilogo delle formule</h2>

  <table class="comparison-table">
    <thead>
      <tr>
        <th>Formula</th>
        <th>Quando usarla</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="font-family:'JetBrains Mono',monospace; font-size:0.9rem;">mâ‚vâ‚ + mâ‚‚vâ‚‚ = (mâ‚+mâ‚‚)Â·v<sub>f</sub></td>
        <td>Durante l'urto (sempre valida)</td>
      </tr>
      <tr>
        <td style="font-family:'JetBrains Mono',monospace; font-size:0.9rem;">E<sub>k</sub> = Â½mvÂ²</td>
        <td>Per calcolare energia prima/dopo</td>
      </tr>
      <tr>
        <td style="font-family:'JetBrains Mono',monospace; font-size:0.9rem;">v<sub>f</sub>Â² = 2gh</td>
        <td>Pendolo: da velocitÃ  ad altezza (o viceversa)</td>
      </tr>
      <tr>
        <td style="font-family:'JetBrains Mono',monospace; font-size:0.9rem;">h = L(1 âˆ’ cos Î¸)</td>
        <td>Pendolo: da altezza ad angolo (o viceversa)</td>
      </tr>
      <tr>
        <td style="font-family:'JetBrains Mono',monospace; font-size:0.9rem;">F<sub>att</sub> Â· d = Â½mvÂ²</td>
        <td>Frenata con attrito dopo l'urto</td>
      </tr>
    </tbody>
  </table>

  <div class="concept-card warning">
    <div class="card-title">âš  L'errore piÃ¹ comune</div>
    <p>
      Non usate la conservazione dell'energia cinetica <strong>durante</strong> l'urto anelastico! L'energia cinetica si conserva solo negli urti elastici. Nell'urto anelastico si conserva solo la quantitÃ  di moto.
    </p>
  </div>

  <div class="concept-card success">
    <div class="card-title">âœ“ Ricorda</div>
    <p>
      <strong>QuantitÃ  di moto</strong> â†’ si conserva SEMPRE (durante l'urto)<br>
      <strong>Energia meccanica</strong> â†’ si conserva SOLO DOPO l'urto (pendolo senza attrito)<br>
      <strong>Energia cinetica</strong> â†’ si dissipa durante l'urto anelastico
    </p>
  </div>
</section>

</main>

<footer>
  Lezione â€” Urto perfettamente anelastico Â· Classe 4L Â· Prof. Ferraro Â· Liceo Galilei Dolo
</footer>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• JAVASCRIPT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script>
// â”€â”€â”€ Utility â”€â”€â”€
const dpr = window.devicePixelRatio || 1;

function setupCanvas(canvas) {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { ctx, w: rect.width, h: rect.height };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SIMULATION 1: Linear collision on a track
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let sim1 = {
  running: false,
  phase: 'before', // 'before', 'colliding', 'after'
  m1: 0.5, v1: 6.0,
  m2: 2.5, v2: 0.0,
  // positions (in display coords, px)
  x1: 0, x2: 0,
  animId: null,
  t: 0
};

function resetSim1() {
  sim1.running = false;
  sim1.phase = 'before';
  sim1.t = 0;
  if (sim1.animId) cancelAnimationFrame(sim1.animId);
  document.getElementById('vf1').textContent = 'â€” m/s';
  document.getElementById('ek_dopo1').textContent = 'â€” J';
  drawSim1Static();
}

function drawSim1Static() {
  const canvas = document.getElementById('canvas1');
  const { ctx, w, h } = setupCanvas(canvas);

  ctx.clearRect(0, 0, w, h);

  // Track
  const trackY = h * 0.65;
  ctx.strokeStyle = '#2a2e3d';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(40, trackY);
  ctx.lineTo(w - 40, trackY);
  ctx.stroke();

  // Ticks on track
  ctx.strokeStyle = '#1f2330';
  for (let x = 60; x < w - 40; x += 40) {
    ctx.beginPath();
    ctx.moveTo(x, trackY);
    ctx.lineTo(x, trackY + 8);
    ctx.stroke();
  }

  // Body 1 (small, left)
  const b1w = 40, b1h = 40;
  sim1.x1 = 120;
  ctx.fillStyle = '#4fc3f7';
  ctx.beginPath();
  roundRect(ctx, sim1.x1 - b1w/2, trackY - b1h, b1w, b1h, 4);
  ctx.fill();
  ctx.fillStyle = '#0d0f15';
  ctx.font = '600 13px "JetBrains Mono"';
  ctx.textAlign = 'center';
  ctx.fillText('mâ‚', sim1.x1, trackY - b1h/2 + 5);

  // Velocity arrow
  drawArrow(ctx, sim1.x1 + b1w/2 + 8, trackY - b1h/2, sim1.x1 + b1w/2 + 55, trackY - b1h/2, '#4fc3f7');
  ctx.fillStyle = '#4fc3f7';
  ctx.font = '500 12px "JetBrains Mono"';
  ctx.fillText('vâ‚', sim1.x1 + b1w/2 + 32, trackY - b1h/2 - 10);

  // Body 2 (large, right)
  const b2w = 80, b2h = 60;
  sim1.x2 = w * 0.65;
  ctx.fillStyle = '#ff7043';
  ctx.beginPath();
  roundRect(ctx, sim1.x2 - b2w/2, trackY - b2h, b2w, b2h, 4);
  ctx.fill();
  ctx.fillStyle = '#0d0f15';
  ctx.font = '600 14px "JetBrains Mono"';
  ctx.fillText('mâ‚‚', sim1.x2, trackY - b2h/2 + 5);

  // Label
  ctx.fillStyle = '#8a8fa8';
  ctx.font = '400 13px "Source Sans 3"';
  ctx.textAlign = 'center';
  ctx.fillText('Premi â–¶ per avviare', w/2, h - 15);
}

function startSim1() {
  if (sim1.running) return;
  resetSim1();
  sim1.running = true;
  sim1.phase = 'before';
  sim1.t = 0;

  const canvas = document.getElementById('canvas1');
  const { w, h } = setupCanvas(canvas);
  const trackY = h * 0.65;

  // Positions in "sim" space
  let x1 = 120;
  const x2start = w * 0.65;
  let x2 = x2start;
  const speed1 = 2.5; // px per frame (visual)
  const vf = (sim1.m1 * sim1.v1 + sim1.m2 * sim1.v2) / (sim1.m1 + sim1.m2);
  const speedF = speed1 * vf / sim1.v1;
  let merged = false;
  let flashT = 0;

  function animate() {
    const { ctx, w, h } = setupCanvas(canvas);
    ctx.clearRect(0, 0, w, h);

    // Track
    ctx.strokeStyle = '#2a2e3d';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(40, trackY);
    ctx.lineTo(w - 40, trackY);
    ctx.stroke();

    for (let xx = 60; xx < w - 40; xx += 40) {
      ctx.strokeStyle = '#1f2330';
      ctx.beginPath();
      ctx.moveTo(xx, trackY);
      ctx.lineTo(xx, trackY + 8);
      ctx.stroke();
    }

    const b1w = 40, b1h = 40;
    const b2w = 80, b2h = 60;

    if (!merged) {
      // Move body 1
      x1 += speed1;

      // Check collision
      if (x1 + b1w/2 >= x2 - b2w/2) {
        merged = true;
        x1 = x2 - b2w/2 - b1w/2 + 5;
        flashT = 15;

        // Update info
        document.getElementById('vf1').textContent = vf.toFixed(2) + ' m/s';
        const ekPrima = 0.5 * sim1.m1 * sim1.v1 * sim1.v1;
        const ekDopo = 0.5 * (sim1.m1 + sim1.m2) * vf * vf;
        document.getElementById('ek_dopo1').textContent = ekDopo.toFixed(2) + ' J';
      }

      // Draw body 1
      ctx.fillStyle = '#4fc3f7';
      roundRect(ctx, x1 - b1w/2, trackY - b1h, b1w, b1h, 4);
      ctx.fill();
      ctx.fillStyle = '#0d0f15';
      ctx.font = '600 13px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('mâ‚', x1, trackY - b1h/2 + 5);

      if (!merged) {
        drawArrow(ctx, x1 + b1w/2 + 8, trackY - b1h/2, x1 + b1w/2 + 45, trackY - b1h/2, '#4fc3f7');
      }

      // Draw body 2 (static)
      ctx.fillStyle = '#ff7043';
      roundRect(ctx, x2 - b2w/2, trackY - b2h, b2w, b2h, 4);
      ctx.fill();
      ctx.fillStyle = '#0d0f15';
      ctx.font = '600 14px "JetBrains Mono"';
      ctx.fillText('mâ‚‚', x2, trackY - b2h/2 + 5);

    } else {
      // Merged: move together
      x1 += speedF;
      x2 += speedF;

      // Flash effect
      if (flashT > 0) {
        ctx.fillStyle = `rgba(255,255,255,${flashT/30})`;
        ctx.fillRect(0, 0, w, h);
        flashT--;
      }

      // Draw merged body
      const mergedW = b1w + b2w - 10;
      const mergedH = b2h;
      const mergedX = (x1 + x2) / 2;

      // Combined body
      ctx.fillStyle = '#b06840';
      roundRect(ctx, mergedX - mergedW/2, trackY - mergedH, mergedW, mergedH, 4);
      ctx.fill();

      // Blue portion
      ctx.fillStyle = '#4fc3f7';
      roundRect(ctx, mergedX - mergedW/2, trackY - mergedH, b1w - 5, mergedH, 4);
      ctx.fill();

      ctx.fillStyle = '#0d0f15';
      ctx.font = '600 12px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('mâ‚+mâ‚‚', mergedX, trackY - mergedH/2 + 5);

      // Slow arrow
      drawArrow(ctx, mergedX + mergedW/2 + 8, trackY - mergedH/2, mergedX + mergedW/2 + 28, trackY - mergedH/2, '#66bb6a');
      ctx.fillStyle = '#66bb6a';
      ctx.font = '500 12px "JetBrains Mono"';
      ctx.fillText('v_f', mergedX + mergedW/2 + 18, trackY - mergedH/2 - 10);

      // Label
      ctx.fillStyle = '#66bb6a';
      ctx.font = '500 13px "Source Sans 3"';
      ctx.textAlign = 'center';
      ctx.fillText('Si muovono insieme!', mergedX, trackY - mergedH - 14);

      if (mergedX > w - 60) {
        sim1.running = false;
        return;
      }
    }

    sim1.animId = requestAnimationFrame(animate);
  }

  sim1.animId = requestAnimationFrame(animate);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SIMULATION 2: Ballistic pendulum
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let sim2 = {
  running: false,
  animId: null,
};

function resetSim2() {
  sim2.running = false;
  if (sim2.animId) cancelAnimationFrame(sim2.animId);
  document.getElementById('vf2').textContent = 'â€” m/s';
  document.getElementById('hmax2').textContent = 'â€” m';
  document.getElementById('thetamax2').textContent = 'â€” Â°';
  drawSim2Static();
}

function drawSim2Static() {
  const canvas = document.getElementById('canvas2');
  const { ctx, w, h } = setupCanvas(canvas);
  ctx.clearRect(0, 0, w, h);

  const pivotX = w * 0.55;
  const pivotY = 30;
  const ropeLen = 200;
  const blockW = 50, blockH = 40;

  // Pivot
  ctx.fillStyle = '#2a2e3d';
  ctx.fillRect(pivotX - 30, 0, 60, 10);

  // Rope
  ctx.strokeStyle = '#5a5f78';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(pivotX, pivotY);
  ctx.lineTo(pivotX, pivotY + ropeLen);
  ctx.stroke();

  // Block
  const blockCX = pivotX;
  const blockCY = pivotY + ropeLen + blockH/2;
  ctx.fillStyle = '#ff7043';
  roundRect(ctx, blockCX - blockW/2, blockCY - blockH/2, blockW, blockH, 4);
  ctx.fill();
  ctx.fillStyle = '#0d0f15';
  ctx.font = '600 11px "JetBrains Mono"';
  ctx.textAlign = 'center';
  ctx.fillText('M', blockCX, blockCY + 4);

  // Bullet
  const bulletX = 80;
  const bulletY = blockCY;
  ctx.fillStyle = '#4fc3f7';
  ctx.beginPath();
  ctx.ellipse(bulletX, bulletY, 14, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#0d0f15';
  ctx.font = '600 9px "JetBrains Mono"';
  ctx.fillText('m', bulletX, bulletY + 3);

  // Arrow
  drawArrow(ctx, bulletX + 20, bulletY, bulletX + 70, bulletY, '#4fc3f7');
  ctx.fillStyle = '#4fc3f7';
  ctx.font = '500 12px "JetBrains Mono"';
  ctx.fillText('vâ‚', bulletX + 45, bulletY - 14);

  // Label
  ctx.fillStyle = '#8a8fa8';
  ctx.font = '400 13px "Source Sans 3"';
  ctx.textAlign = 'center';
  ctx.fillText('Premi â–¶ per avviare', w/2, h - 15);
}

function startSim2() {
  if (sim2.running) return;
  resetSim2();
  sim2.running = true;

  const canvas = document.getElementById('canvas2');
  const { w, h } = setupCanvas(canvas);

  const m1 = 0.010, v1 = 850, m2 = 4.0;
  const vf = (m1 * v1) / (m1 + m2);
  const g = 9.81;
  const hMax = (vf * vf) / (2 * g);
  const L = 1.5;
  const cosTheta = 1 - hMax / L;
  const thetaMax = Math.acos(Math.max(-1, Math.min(1, cosTheta)));
  const thetaMaxDeg = thetaMax * 180 / Math.PI;

  document.getElementById('vf2').textContent = vf.toFixed(2) + ' m/s';
  document.getElementById('hmax2').textContent = hMax.toFixed(3) + ' m';
  document.getElementById('thetamax2').textContent = thetaMaxDeg.toFixed(1) + 'Â°';

  const pivotX = w * 0.55;
  const pivotY = 30;
  const ropeLen = 200;
  const blockW = 50, blockH = 40;

  let bulletX = 80;
  const bulletTargetX = pivotX - blockW/2;
  const bulletY = pivotY + ropeLen + blockH/2;

  let phase = 'bullet_flying'; // bullet_flying, flash, swinging
  let flashT = 0;
  let swingT = 0;
  const bulletSpeed = 8;

  // Swing params
  const swingDuration = 180; // frames to reach max
  const damping = 0.985;

  function animate() {
    const { ctx, w, h } = setupCanvas(canvas);
    ctx.clearRect(0, 0, w, h);

    // Pivot bar
    ctx.fillStyle = '#2a2e3d';
    ctx.fillRect(pivotX - 30, 0, 60, 10);

    if (phase === 'bullet_flying') {
      bulletX += bulletSpeed;
      if (bulletX >= bulletTargetX - 10) {
        phase = 'flash';
        flashT = 20;
      }

      // Rope + block (static)
      ctx.strokeStyle = '#5a5f78';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pivotX, pivotY);
      ctx.lineTo(pivotX, pivotY + ropeLen);
      ctx.stroke();

      ctx.fillStyle = '#ff7043';
      roundRect(ctx, pivotX - blockW/2, bulletY - blockH/2, blockW, blockH, 4);
      ctx.fill();

      // Bullet
      ctx.fillStyle = '#4fc3f7';
      ctx.beginPath();
      ctx.ellipse(bulletX, bulletY, 14, 7, 0, 0, Math.PI * 2);
      ctx.fill();

    } else if (phase === 'flash') {
      flashT--;
      if (flashT <= 0) {
        phase = 'swinging';
        swingT = 0;
      }

      // Flash
      ctx.fillStyle = `rgba(255,255,200,${flashT/30})`;
      ctx.fillRect(0, 0, w, h);

      // Block at rest
      ctx.strokeStyle = '#5a5f78';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pivotX, pivotY);
      ctx.lineTo(pivotX, pivotY + ropeLen);
      ctx.stroke();

      const mergedColor = '#d4724a';
      ctx.fillStyle = mergedColor;
      roundRect(ctx, pivotX - blockW/2, bulletY - blockH/2, blockW, blockH, 4);
      ctx.fill();

      ctx.fillStyle = '#0d0f15';
      ctx.font = '600 10px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('m+M', pivotX, bulletY + 4);

    } else {
      // Swinging phase
      swingT++;

      // Angle: ease up to thetaMax, then oscillate with damping
      let angle;
      const riseFrames = 90;
      if (swingT < riseFrames) {
        // Ease to max angle
        const t = swingT / riseFrames;
        const ease = t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
        angle = thetaMax * ease;
      } else {
        // Oscillate
        const elapsed = swingT - riseFrames;
        const period = 120;
        const dampFactor = Math.pow(damping, elapsed);
        angle = thetaMax * Math.cos(2 * Math.PI * elapsed / period) * dampFactor;
      }

      // Block position
      const bx = pivotX + Math.sin(angle) * ropeLen;
      const by = pivotY + Math.cos(angle) * ropeLen;

      // Rope
      ctx.strokeStyle = '#5a5f78';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(pivotX, pivotY);
      ctx.lineTo(bx, by);
      ctx.stroke();

      // Ghost of rest position
      ctx.strokeStyle = 'rgba(90,95,120,0.2)';
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(pivotX, pivotY);
      ctx.lineTo(pivotX, pivotY + ropeLen);
      ctx.stroke();
      ctx.setLineDash([]);

      // Height line (when near max)
      if (swingT < riseFrames + 30) {
        const currentH = ropeLen - Math.cos(angle) * ropeLen;
        if (currentH > 2) {
          const restBottom = pivotY + ropeLen + blockH/2;
          const currentBottom = by + blockH/2;
          ctx.strokeStyle = 'rgba(102,187,106,0.5)';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(bx + blockW/2 + 15, restBottom);
          ctx.lineTo(bx + blockW/2 + 15, currentBottom);
          ctx.stroke();
          ctx.setLineDash([]);

          // h label
          ctx.fillStyle = '#66bb6a';
          ctx.font = '500 12px "JetBrains Mono"';
          ctx.textAlign = 'left';
          ctx.fillText('h', bx + blockW/2 + 22, (restBottom + currentBottom)/2 + 4);
        }

        // Angle arc
        if (Math.abs(angle) > 0.02) {
          ctx.strokeStyle = 'rgba(79,195,247,0.4)';
          ctx.lineWidth = 1;
          const arcR = 60;
          ctx.beginPath();
          const startA = Math.PI/2;
          const endA = Math.PI/2 - angle;
          ctx.arc(pivotX, pivotY, arcR, Math.min(startA, endA), Math.max(startA, endA));
          ctx.stroke();

          ctx.fillStyle = '#4fc3f7';
          ctx.font = '500 11px "JetBrains Mono"';
          ctx.textAlign = 'center';
          const labelAngle = (startA + endA) / 2;
          ctx.fillText('Î¸', pivotX + Math.cos(labelAngle) * (arcR + 14), pivotY + Math.sin(labelAngle) * (arcR + 14));
        }
      }

      // Block
      ctx.save();
      ctx.translate(bx, by);
      ctx.rotate(angle * 0.15); // slight tilt
      ctx.fillStyle = '#d4724a';
      roundRect(ctx, -blockW/2, -blockH/2, blockW, blockH, 4);
      ctx.fill();
      ctx.fillStyle = '#0d0f15';
      ctx.font = '600 10px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('m+M', 0, 4);
      ctx.restore();

      // Stop after a while
      if (swingT > 500) {
        sim2.running = false;
        return;
      }
    }

    sim2.animId = requestAnimationFrame(animate);
  }

  sim2.animId = requestAnimationFrame(animate);
}


// â”€â”€â”€ Helpers â”€â”€â”€
function drawArrow(ctx, x1, y1, x2, y2, color) {
  const headLen = 8;
  const angle = Math.atan2(y2-y1, x2-x1);
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLen*Math.cos(angle - Math.PI/6), y2 - headLen*Math.sin(angle - Math.PI/6));
  ctx.lineTo(x2 - headLen*Math.cos(angle + Math.PI/6), y2 - headLen*Math.sin(angle + Math.PI/6));
  ctx.closePath();
  ctx.fill();
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.arcTo(x + w, y, x + w, y + r, r);
  ctx.lineTo(x + w, y + h - r);
  ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
  ctx.lineTo(x + r, y + h);
  ctx.arcTo(x, y + h, x, y + h - r, r);
  ctx.lineTo(x, y + r);
  ctx.arcTo(x, y, x + r, y, r);
  ctx.closePath();
}

// â”€â”€â”€ Init â”€â”€â”€
window.addEventListener('load', () => {
  drawSim1Static();
  drawSim2Static();
});

window.addEventListener('resize', () => {
  if (!sim1.running) drawSim1Static();
  if (!sim2.running) drawSim2Static();
});
</script>

</body>
</html>
